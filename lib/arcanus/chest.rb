require 'base64'
require 'digest'
require 'securerandom'
require 'yaml'

module Arcanus
  # Encapsulates the collection of encrypted secrets managed by Arcanus.
  class Chest # rubocop:disable Metrics/ClassLength
    SIGNATURE_SIZE_BITS = 256

    def initialize(key_file_path:, chest_file_path:)
      @key = Key.from_file(key_file_path)
      @chest_file_path = chest_file_path
      @original_encrypted_hash = YAML.load_file(chest_file_path).to_hash
      @original_decrypted_hash = decrypt_hash(@original_encrypted_hash)
      @hash = Utils.deep_dup(@original_decrypted_hash)
    end

    # Access the chest as if it were a hash.
    #
    # @param key [String]
    # @return [Object]
    def [](key)
      @hash[key]
    end

    # Fetch key from the chest as if it were a hash.
    def fetch(*args)
      @hash.fetch(*args)
    end

    # Returns the contents of the chest as a hash.
    def contents
      @hash
    end

    # Provides access to chest items using regular method calls instead of hash
    # accesses.
    def method_missing(method_sym, *)
      method_name = method_sym.to_s
      if @hash.key?(method_name)
        value = @hash[method_name]
        if value.is_a?(Hash)
          Item.new(value, [method_name])
        else
          value
        end
      else
        raise KeyError, "No key '#{method_name}' exists in this chest"
      end
    end

    # Set value for the specified key path.
    #
    # @param key_path [String]
    # @param value [Object]
    def set(key_path, value)
      keys = key_path.split('.')
      nested_hash = keys[0..-2].inject(@hash) { |hash, key| hash[key] }
      nested_hash[keys[-1]] = value
    rescue NoMethodError
      raise Arcanus::Errors::InvalidKeyPathError,
            "Key path '#{key_path}' does not correspond to an actual key"
    end

    # Get value at the specified key path.
    #
    # @param key_path [String]
    # @return [Object]
    def get(key_path)
      keys = key_path.split('.')
      keys.inject(@hash) { |hash, key| hash[key] }
    rescue NoMethodError
      raise Arcanus::Errors::InvalidKeyPathError,
            "Key path '#{key_path}' does not correspond to an actual key"
    end

    def update(new_hash)
      @hash = new_hash
    end

    # For each key in the chest, encrypt the new value if it has changed.
    #
    # The goal is to create a file where the only lines that differ are the keys
    # that changed.
    def save
      modified_hash =
        process_hash_changes(@original_encrypted_hash, @original_decrypted_hash, @hash)

      File.open(@chest_file_path, 'w') do |f|
        f.puts('# Do not edit this file directly! Run `arcanus edit`')
        f.write(modified_hash.to_yaml)
      end
    end

    private

    def process_hash_changes(original_encrypted, original_decrypted, current) # rubocop:disable Metrics/MethodLength, Metrics/LineLength
      result = {}

      current.keys.each do |key|
        value = current[key]

        result[key] =
          if original_encrypted.key?(key)
            # Key still exists; check if modified.
            if value.is_a?(Hash)
              if original_encrypted[key].is_a?(Hash)
                process_hash_changes(original_encrypted[key], original_decrypted[key], value)
              else
                # Key changed from single value to hash, so no previous has to compare against
                process_hash_changes({}, {}, value)
              end
            elsif original_decrypted[key] != value
              # Value was changed; encrypt the new value
              encrypt_value(value)
            else
              # Value wasn't changed; keep original encrypted blob
              original_encrypted[key]
            end
          else
            # Key was added
            value.is_a?(Hash) ? process_hash_changes({}, {}, value) : encrypt_value(value)
          end
      end

      result
    end

    def decrypt_hash(hash)
      hash.each_with_object({}) do |(key, value), decrypted_hash|
        begin
          decrypted_hash[key] = value.is_a?(Hash) ? decrypt_hash(value) : decrypt_value(value)
        rescue Errors::DecryptionError => ex
          raise Errors::DecryptionError,
                "Problem decrypting value for key '#{key}': #{ex.message}"
        end
      end
    end

    def encrypt_value(value)
      dumped_value = Marshal.dump(value)
      encrypted_value = Base64.encode64(@key.encrypt(dumped_value))
      salt = SecureRandom.hex(8)

      signature = Digest::SHA2.new(SIGNATURE_SIZE_BITS).tap do |digest|
        digest << salt
        digest << dumped_value
      end.to_s

      "#{encrypted_value}:#{salt}:#{signature}"
    end

    def decrypt_value(blob)
      unless blob.is_a?(String)
        raise Errors::DecryptionError,
              "Expecting an encrypted blob but got '#{blob}'"
      end

      encrypted_value, salt, signature = blob.split(':')

      if signature.nil? || salt.nil? || encrypted_value.nil?
        raise Errors::DecryptionError,
              "Invalid blob format '#{blob}' (must be of the form 'signature:salt:ciphertext')"
      end

      dumped_value = @key.decrypt(Base64.decode64(encrypted_value))

      actual_signature = Digest::SHA2.new(SIGNATURE_SIZE_BITS).tap do |digest|
        digest << salt
        digest << dumped_value
      end.to_s

      if signature != actual_signature
        raise Errors::DecryptionError,
              'Signature of decrypted value does not match: ' \
              "expected #{signature} but got #{actual_signature}"
      end

      Marshal.load(dumped_value)
    end

    # Helper class for returning contents nested hashes, exposing helpers to
    # access them via method calls.
    class Item
      def initialize(hash, prefix = [])
        @hash = hash
        @prefix = prefix
      end

      def method_missing(method_sym, *)
        method_name = method_sym.to_s
        if @hash.key?(method_name)
          value = @hash[method_name]
          if value.is_a?(Hash)
            Item.new(value, @prefix + [method_name])
          else
            value
          end
        else
          key_name = "#{@prefix.join('.')}.#{method_name}"
          raise KeyError, "No key '#{key_name}' exists in this chest"
        end
      end

      # Access the item as if it were a hash.
      #
      # @param key [String]
      # @return [Object]
      def [](key)
        @hash[key]
      end

      # Fetch key from the chest as if it were a hash.
      def fetch(*args)
        @hash.fetch(*args)
      end

      def to_s
        @hash.to_s
      end

      def inspect
        @hash.inspect
      end

      # Implicit conversion to array. Needs to be defined so we can `puts` this
      # value.
      def to_ary
        [@hash]
      end
    end
  end
end
